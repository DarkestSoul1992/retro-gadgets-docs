[Тільки для читання]# CPU

<img src="https://docs.retrogadgets.game/api/modules/CPU.png" width="200" align="right">

CPU відповідає за більшу частину інтерактивності гаджета і запускає файли Lua. CPU (в даний час) не потрібно підключати до будь-якої частини гаджета, або на платі, з якою вони взаємодіють. Наразі вони можуть завантажувати лише один файл Lua.

## Властивості

### Source - `Code` **[Тільки для читання]**

Джерело визначає, який "файл" буде виконуватися процесором, і зазвичай встановлюється за допомогою мультитула. Ви можете встановити його на будь-який ресурс Lua. Після створення CPU автоматично створюється файл коду з назвою CPU0.lua, і він автоматично підключається до зазначеного CPU.

### Time - `number` **[Тільки для читання]**

Час з моменту увімкнення гаджета, виражений у секундах.

```lua
local cpu:CPU = gdt.CPU0
function update()
	log(tostring(cpu.Time)) -- 0.521000027656552 (Час буде змінюватися)
end
```

### DeltaTime - `number` **[Тільки для читання]**

Час, що минув з моменту останнього тіку, виражений в секундах. По суті, це різниця (або _дельта_) між останніми викликами `update()`. Це корисно для оновлення анімацій і таймерів, не покладаючись на запам'ятовування `Time`, а також для плавної інтерполяції значень (див. "Створення послідовної інтерполяції").

```lua
local cpu:CPU = gdt.CPU0
function update()
	log(tostring(cpu.DeltaTime)) -- При 60 з 60 тіків/с це приблизно 0,01666.
	-- Прикладом реальної величини є: 0.01600000075995922
end
```

## Зауваження

### Створення послідовної інтерполяції

<!-- не впевнені, що retro gadgets вже обробляють дельтатайм? видаліть цей розділ, якщо це так -->

Переконатися, що рух чогось залишається послідовним, неймовірно важливо при виконанні будь-яких дій, пов'язаних з рухом. Якщо Ви переміщуєте квадрат зі швидкістю 60 кадрів в секунду, ви хочете перемістити його на таку ж відстань і за 5 кадрів в секунду. Однак, у більшості випадків цього не відбувається. Якщо ви переходите від значення 0 до 100, збільшуючи на 1 кожен кадр:
```lua
local myNumber:number = 0

-- update() викликається кожен кадр
function update()
  myNumber = myNumber + 1
end
```

У більшості випадків це буде добре працювати, якщо частота кадрів буде постійною. Однак, у випадку, якщо це не так, час, який знадобиться для того, щоб `myNumber` досяг 100, буде відрізнятися між різними частотами кадрів. Це може створювати проблеми в сценаріях, де вам потрібно, щоб приріст змінної був послідовним (наприклад, рух персонажа), тому важливо знайти спосіб синхронізувати його з FPS. Ця практика застосовується в більшості випадків, коли мова йде про інтерполяцію даних, які повинні бути послідовними, і включає лише кілька додаткових символів:

```lua
local myNumber:number = 0
local cpu:CPU = gdt.CPU0 -- Замініть тут на свій CPU

function update()
	myNumber = myNumber + (1 * cpu.DeltaTime)
end
```

Оскільки ми помножили значення приросту на DeltaTime, незалежно від частоти кадрів, в довгостроковій перспективі все одно знадобиться однакова кількість часу для того, щоб `myNumber` досяг 100.
